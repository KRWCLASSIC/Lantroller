<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PC Control Panel</title>
<style>
:root { --bg:#0f1220; --panel:#171a2b; --accent:#6c8cff; --accent-2:#22c55e; --text:#e5e7eb; --muted:#9ca3af; --danger:#ef4444; --warning:#f59e0b; --card:#0b0e1a; --border:#2a2f45; }
* { box-sizing: border-box; }
body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%); color: var(--text); }
.container { max-width: 1100px; margin: 0 auto; padding: 24px; }
.header { display:flex; align-items:center; justify-content: space-between; margin-bottom: 16px; }
.brand { display:flex; align-items:center; gap:12px; }
.brand .logo { width:36px; height:36px; border-radius: 10px; background: linear-gradient(135deg, var(--accent), #a78bfa); display:grid; place-items:center; font-weight: 800; }
.brand h1 { font-size: 20px; margin:0; letter-spacing: 0.3px; }
.header .status { font-size: 12px; color: var(--muted); display:flex; align-items:center; gap:8px; }
.dot { width:10px; height:10px; border-radius:50%; background:#475569; box-shadow: 0 0 0 2px rgba(0,0,0,0.2) inset; }
.dot.online { background:#22c55e; }
.dot.offline { background:#ef4444; }
.panel { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.25); }
.grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
.card { background: linear-gradient(180deg, var(--card), var(--panel)); border:1px solid var(--border); border-radius:12px; padding:14px; }
.card h3 { margin:0 0 8px 0; font-size:14px; color: var(--muted); font-weight:600; letter-spacing: .4px; }
.buttons { display:flex; flex-wrap:wrap; gap:8px; }
button { appearance:none; border:1px solid var(--border); background: #1c2140; color: var(--text); padding:10px 12px; border-radius:8px; font-size:14px; cursor:pointer; transition: .15s ease; }
button:hover { transform: translateY(-1px); border-color: var(--accent); box-shadow: 0 6px 14px rgba(108,140,255,.2); }
button.primary { background: linear-gradient(135deg, var(--accent), #8b5cf6); border-color: transparent; }
button.success { background: linear-gradient(135deg, var(--accent-2), #16a34a); border-color: transparent; }
button.warning { background: linear-gradient(135deg, var(--warning), #f97316); border-color: transparent; }
button.danger { background: linear-gradient(135deg, var(--danger), #b91c1c); border-color: transparent; }
.button.small, button.small { padding: 6px 8px; font-size: 12px; }
.row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
.input { display:flex; gap:8px; width:100%; }
.input input { flex:1; min-width: 140px; background:#0f132d; color: var(--text); border:1px solid var(--border); border-radius:8px; padding:10px 12px; outline:none; }
.terminal { height: 280px; overflow:auto; background:#0a0d1c; border:1px solid var(--border); border-radius: 10px; padding:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; white-space: pre-wrap; }
.terminal.small { height: 180px; }
.badge { display:inline-flex; align-items:center; gap:6px; border:1px solid var(--border); padding:6px 8px; border-radius:999px; color: var(--muted); }
.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; background:#11152d; border:1px solid var(--border); padding:2px 6px; border-radius:6px; color: var(--text); }
.footer { margin-top: 18px; display:flex; gap:8px; flex-wrap:wrap; justify-content: space-between; color: var(--muted); font-size: 12px; }
.mt-12 { margin-top:12px; }
.flex-1 { flex:1; }
.link { color: var(--text); text-decoration: underline dotted; cursor: pointer; }
.hidden { display:none; }
.muted { color: var(--muted); }
.mb-14 { margin-bottom:14px; }
.mb-10 { margin-bottom:10px; }
.touchpad-canvas { background:#0a0d1c; border:1px solid var(--border); border-radius:10px; touch-action:none; }
.touchpad-wrap { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
.col-gap-8 { display:flex; flex-direction:column; gap:8px; }
/* Touchpad sensitivity slider */
.sens-range { width: 160px; }
/* Styled range input for sensitivity */
.sens-range {
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 999px;
  background: #1c2140;
  border: 1px solid var(--border);
}
.sens-range:focus { outline: none; }
.sens-range::-webkit-slider-runnable-track {
  height: 6px;
  background: linear-gradient(90deg, var(--accent), #8b5cf6);
  border-radius: 999px;
}
.sens-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #e5e7eb;
  border: 1px solid var(--border);
  margin-top: -5px;
}
.sens-range::-moz-range-track {
  height: 6px;
  background: linear-gradient(90deg, var(--accent), #8b5cf6);
  border-radius: 999px;
}
.sens-range::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #e5e7eb;
  border: none;
}
.sens-range::-ms-track {
  height: 6px;
  background: transparent;
  border-color: transparent;
  color: transparent;
}
.sens-range::-ms-fill-lower { background: var(--accent); border-radius: 999px; }
.sens-range::-ms-fill-upper { background: #8b5cf6; border-radius: 999px; }

/* Arrow buttons (pure text) */
.icon-btn { padding: 4px 8px; font-size: 12px; line-height: 1; }
/* Slightly smaller buttons for the mini keyboard */
#mini-kb button { padding: 8px 10px; font-size: 12px; }
/* Prevent native long-press/callout and selection on mini keyboard keys */
#mini-kb button {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
@media (max-width: 640px) {
  .container { padding: 16px; }
  .grid { grid-template-columns: 1fr; }
  .row { gap: 10px; }
  .input { flex-direction: column; }
  .input input { width: 100%; }
  .input button { width: 100%; }
  .buttons { flex-direction: column; }
  .buttons button { width: 100%; }
  .terminal { height: 220px; }
  .terminal.small { height: 140px; }
  /* Smaller mono font for logs/output on mobile */
  .terminal { font-size: 12px; line-height: 1.35; }
  .terminal.small { font-size: 11.5px; }
  /* Make touchpad smaller and full-width on mobile */
  .touchpad-canvas { width: 100%; height: 140px; }
  /* Make mini keyboard more compact on mobile */
  #mini-kb button { padding: 6px 8px; font-size: 11px; }
}
</style>
<script>
// Versions (edit here)
const UI_VERSION = 'v7';
const BACKEND_VERSION = 'local';

async function run(cmd) {
  const res = await fetch(`/actions?cmd=${encodeURIComponent(cmd)}`);
  const text = await res.text();
  toast(text);
}
async function doAction(url) {
  const res = await fetch(url);
  const text = await res.text();
  toast(text);
}
function toast(msg) {
  const el = document.createElement('div');
  el.textContent = typeof msg === 'string' ? msg : JSON.stringify(msg);
  el.style.position = 'fixed';
  el.style.bottom = '20px';
  el.style.left = '50%';
  el.style.transform = 'translateX(-50%)';
  el.style.background = '#11152d';
  el.style.border = '1px solid #2a2f45';
  el.style.color = '#e5e7eb';
  el.style.padding = '10px 12px';
  el.style.borderRadius = '10px';
  el.style.zIndex = 9999;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2000);
}
async function execLive() {
  const input = document.getElementById('cmd');
  const output = document.getElementById('output');
  const sendBtn = document.getElementById('sendBtn');
  const cmd = input.value.trim();
  if (!cmd) { input.focus(); return; }
  output.textContent = '';
  sendBtn.disabled = true;
  let controller = new AbortController();
  window._execController = controller;
  try {
    const res = await fetch('/exec', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ cmd }),
      signal: controller.signal
    });
    if (!res.body) {
      output.textContent = await res.text();
      return;
    }
    const reader = res.body.getReader();
    const decoder = new TextDecoder('utf-8');
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      output.textContent += decoder.decode(value, { stream: true });
      output.scrollTop = output.scrollHeight;
    }
  } catch (e) {
    output.textContent += `\n[Error] ${e}\n`;
  } finally {
    sendBtn.disabled = false;
  }
}
function quickFill(example) {
  const input = document.getElementById('cmd');
  input.value = example;
  input.focus();
}

async function pollHealth() {
  try {
    const res = await fetch('/health', { cache: 'no-store' });
    const ok = res.ok;
    const dot = document.getElementById('statusDot');
    const label = document.getElementById('statusText');
    if (ok) {
      dot.classList.add('online');
      dot.classList.remove('offline');
      label.textContent = 'Online';
    } else {
      dot.classList.add('offline');
      dot.classList.remove('online');
      label.textContent = 'Offline';
    }
  } catch {
    const dot = document.getElementById('statusDot');
    const label = document.getElementById('statusText');
    dot.classList.add('offline');
    dot.classList.remove('online');
    label.textContent = 'Offline';
  }
}

async function loadLogs() {
  try {
    const res = await fetch('/logs?tail=500', { cache: 'no-store' });
    const text = await res.text();
    const area = document.getElementById('logs');
    area.textContent = text || '<no logs yet>';
    area.scrollTop = area.scrollHeight;
  } catch (e) {
    const area = document.getElementById('logs');
    area.textContent = `Error loading logs: ${e}`;
  }
}

function openRawLogs() {
  window.open('/logs?tail=5000', '_blank');
}

async function clearLogs() {
  try {
    await fetch('/logs/clear', { method: 'POST' });
    await loadLogs();
  } catch (e) {}
}

  // Mouse wheel emulation (hold to repeat)
  function startWheelLoop(direction){
    const delta = direction === 'up' ? 120 : -120;
    let active = true;
    const tick = async () => {
      if (!active) return;
      try { await fetch('/input/mouse/wheel', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ delta }) }); } catch {}
      // Repeat rate ~60ms for smooth but controlled scroll
      setTimeout(tick, 60);
    };
    tick();
    return () => { active = false; };
  }

window.addEventListener('load', () => {
  const verEl = document.getElementById('versions');
  if (verEl) verEl.textContent = `UI ${UI_VERSION} · Backend ${BACKEND_VERSION}`;
  pollHealth();
  setInterval(pollHealth, 1000);
  loadLogs();
  setInterval(loadLogs, 5000);
});
</script>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">
      <div class="logo">PC</div>
      <div>
        <h1>Lantroller</h1>
      </div>
    </div>
    <div class="status">
      <span id="statusDot" class="dot offline"></span>
      <span id="statusText">Offline</span>
      <span class="muted">|</span>
      <span id="versions" class="muted"></span>
    </div>
  </div>

  <div class="panel mb-14">
    <div class="grid">
      <div class="card">
        <h3>Killers</h3>
        <div class="buttons">
          <button onclick="doAction('/kill/discord')">Kill Discord</button>
          <button onclick="doAction('/kill/roblox')">Kill Roblox</button>
          <button onclick="doAction('/kill/steam')">Kill Steam</button>
          <button onclick="doAction('/kill/browser?name=all')">Kill All Browsers</button>
        </div>
      </div>
      <div class="card">
        <h3>Power</h3>
        <div class="buttons">
          <button class="danger" onclick="run('shutdown /s /t 0')">Shutdown</button>
          <button class="warning" onclick="run('shutdown /r /t 0')">Restart</button>
          <button onclick="run('rundll32.exe user32.dll,LockWorkStation')">Lock</button>
        </div>
      </div>
      <div class="card">
        <h3>Maintenance</h3>
        <div class="buttons">
           <button onclick="doAction('/refetch-ui')">Refetch UI</button>
          <button onclick="doAction('/update')">Update Backend</button>
          <button onclick="doAction('/restart')">Restart Server</button>
          <button class="danger" onclick="doAction('/stop')">Stop Lantroller</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="row mb-10">
      <div class="badge">Live Command Execution</div>
    </div>
    <div class="input mb-10">
      <input id="cmd" type="text" placeholder="Enter a command to run, e.g. ipconfig" onkeydown="if(event.key==='Enter') execLive()">
      <button id="sendBtn" class="success small" onclick="execLive()">Send</button>
    </div>
    <div class="terminal" id="output"></div>
  </div>

  <div class="panel mt-12">
    <div class="row mb-10">
      <div class="badge">Mini Keyboard</div>
      <div class="badge muted">Live key down/up</div>
      <div class="flex-1"></div>
      <button id="toggle-listen" class="small">Listen to PC Input</button>
    </div>
    <div id="mini-kb" class="mb-10"></div>
    <div class="row mb-10">
      <div class="badge">Touchpad</div>
      <div class="badge muted">Drag to move · Buttons below · Sensitivity</div>
    </div>
    <div class="touchpad-wrap">
      <canvas id="touchpad" width="320" height="200" class="touchpad-canvas"></canvas>
      <div class="col-gap-8">
        <div class="row">
          <button id="lmb">LMB</button>
          <button id="rmb">RMB</button>
          <button id="mmb">MMB</button>
        </div>
        <div class="row">
          <label for="sens" class="badge muted">Sensitivity</label>
          <input id="sens" class="sens-range" type="range" min="0.5" max="3" step="0.1" value="1" />
          <span id="sensVal" class="badge">1.0</span>
        </div>
        <div class="row">
          <div class="badge muted">Wheel</div>
          <button id="wheel-up" class="icon-btn" title="Wheel Up">▲</button>
          <button id="wheel-down" class="icon-btn" title="Wheel Down">▼</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // Mini keyboard definition
  const MINI_ROWS = [
    ['ESC','F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12'],
    ['1','2','3','4','5','6','7','8','9','0','BACKSPACE'],
    ['TAB','Q','W','E','R','T','Y','U','I','O','P','ENTER'],
    ['CTRL','A','S','D','F','G','H','J','K','L','SHIFT'],
    ['CAPSLOCK','ALT','Z','X','C','V','B','N','M'],
    ['SPACE']
  ];

  function renderMiniKeyboard(){
    const wrap = document.getElementById('mini-kb');
    wrap.innerHTML = '';
    for (const row of MINI_ROWS){
      const rowEl = document.createElement('div');
      rowEl.className = 'row mb-10';
      for (const key of row){
        const btn = document.createElement('button');
        btn.textContent = key.length === 1 ? key : key;
        let active = false;
        btn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
        btn.onpointerdown = (e) => {
          active = true;
          try { btn.setPointerCapture(e.pointerId); } catch {}
          sendKey(key, 'down');
        };
        btn.onpointerup = () => {
          if (active) { sendKey(key, 'up'); active = false; }
        };
        btn.onpointerleave = () => {
          if (active) { sendKey(key, 'up'); active = false; }
        };
        btn.onpointercancel = () => {
          if (active) { sendKey(key, 'up'); active = false; }
        };
        rowEl.appendChild(btn);
      }
      wrap.appendChild(rowEl);
    }
  }

  async function sendKey(key, eventType){
    try {
      await fetch('/input/key', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ key, event: eventType })
      });
    } catch {}
  }

  // Touchpad
  (function(){
    const canvas = document.getElementById('touchpad');
    const ctx = canvas.getContext('2d');
    let last = null;
    const sendEveryMs = 16; // ~60Hz
    let lastSent = 0;
    let sensitivity = 1.0;

    function drawBase(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#0b0e1a';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = '#2a2f45';
      ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);
    }
    drawBase();

    function sendDelta(dx, dy){
      const sdx = Math.round(dx * sensitivity);
      const sdy = Math.round(dy * sensitivity);
      if (sdx === 0 && sdy === 0) return;
      fetch('/input/mouse/move', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({dx: sdx, dy: sdy})}).catch(()=>{});
    }

    function handlePointer(e){
      const now = performance.now();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (last == null) { last = {x, y}; return; }
      const dx = Math.round((x - last.x));
      const dy = Math.round((y - last.y));
      last = {x, y};
      if (now - lastSent >= sendEveryMs){
        lastSent = now;
        if (dx !== 0 || dy !== 0) sendDelta(dx, dy);
      }
    }

    canvas.addEventListener('pointerdown', (e)=>{
      canvas.setPointerCapture(e.pointerId);
      if ((e.button === 2) || (e.buttons & 2)) {
        console.log('[RMB] canvas pointerdown', { button: e.button, buttons: e.buttons, pointerType: e.pointerType });
      }
      last = null;
    });
    canvas.addEventListener('pointermove', (e)=>{ if (e.pressure > 0 || e.buttons) handlePointer(e); });
    canvas.addEventListener('pointerup', ()=>{ last = null; });
    canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); console.log('[RMB] canvas contextmenu prevented'); });

    const sens = document.getElementById('sens');
    const sensVal = document.getElementById('sensVal');
    if (sens && sensVal){
      sens.addEventListener('input', ()=>{
        sensitivity = parseFloat(sens.value) || 1.0;
        sensVal.textContent = sensitivity.toFixed(1);
      });
    }
  })();

  function mouseButton(button, eventType){
    if (button === 'right') {
      console.log(`[RMB] send ${eventType}`);
    }
    fetch('/input/mouse/button', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({button, event: eventType})
    }).then(r => {
      if (button === 'right') {
        console.log(`[RMB] server ${eventType} -> ${r.status}`);
      }
    }).catch(err => {
      if (button === 'right') {
        console.log(`[RMB] error ${eventType}:`, err);
      }
    });
  }
  const lmbBtn = document.getElementById('lmb');
  const rmbBtn = document.getElementById('rmb');
  const wheelUp = document.getElementById('wheel-up');
  const wheelDown = document.getElementById('wheel-down');
  const mmbBtn = document.getElementById('mmb');
  let lmbActive = false;
  let rmbActive = false;
  let mmbActive = false;

  lmbBtn.onpointerdown = (e)=> { lmbActive = true; mouseButton('left','down'); };
  lmbBtn.onpointerup   = (e)=> { if (lmbActive) { mouseButton('left','up'); lmbActive = false; } };
  lmbBtn.onpointerleave= (e)=> { if (lmbActive) { mouseButton('left','up'); lmbActive = false; } };
  lmbBtn.onpointercancel= (e)=> { if (lmbActive) { mouseButton('left','up'); lmbActive = false; } };

  // Prevent native context menu on RMB button and gate events behind active state
  if (rmbBtn) rmbBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); console.log('[RMB] button contextmenu prevented'); });
  rmbBtn.onpointerdown = (e)=> { rmbActive = true; console.log('[RMB] button pointerdown', { button: e.button, buttons: e.buttons, pointerType: e.pointerType }); mouseButton('right','down'); };
  rmbBtn.onpointerup   = (e)=> { if (rmbActive) { console.log('[RMB] button pointerup',   { button: e.button, buttons: e.buttons, pointerType: e.pointerType }); mouseButton('right','up'); rmbActive = false; } else { console.log('[RMB] button pointerup ignored (not active)'); } };
  rmbBtn.onpointerleave= (e)=> { if (rmbActive) { console.log('[RMB] button pointerleave', { button: e.button, buttons: e.buttons, pointerType: e.pointerType }); mouseButton('right','up'); rmbActive = false; } else { console.log('[RMB] button pointerleave ignored (not active)'); } };
  rmbBtn.onpointercancel= (e)=> { if (rmbActive) { console.log('[RMB] button pointercancel', { button: e.button, buttons: e.buttons, pointerType: e.pointerType }); mouseButton('right','up'); rmbActive = false; } };

  if (mmbBtn) mmbBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
  mmbBtn.onpointerdown = (e)=> { mmbActive = true; mouseButton('middle','down'); };
  mmbBtn.onpointerup   = (e)=> { if (mmbActive) { mouseButton('middle','up'); mmbActive = false; } };
  mmbBtn.onpointerleave= (e)=> { if (mmbActive) { mouseButton('middle','up'); mmbActive = false; } };
  mmbBtn.onpointercancel= (e)=> { if (mmbActive) { mouseButton('middle','up'); mmbActive = false; } };

  renderMiniKeyboard();

  const keyMap = {
    "Escape": "ESC",
    "F1": "F1", "F2": "F2", "F3": "F3", "F4": "F4", "F5": "F5", "F6": "F6",
    "F7": "F7", "F8": "F8", "F9": "F9", "F10": "F10", "F11": "F11", "F12": "F12",
    "Backquote": "~",
    "Digit1": "1", "Digit2": "2", "Digit3": "3", "Digit4": "4", "Digit5": "5",
    "Digit6": "6", "Digit7": "7", "Digit8": "8", "Digit9": "9", "Digit0": "0",
    "Backspace": "BACKSPACE",
    "Tab": "TAB",
    "KeyQ": "Q", "KeyW": "W", "KeyE": "E", "KeyR": "R", "KeyT": "T", "KeyY": "Y",
    "KeyU": "U", "KeyI": "I", "KeyO": "O", "KeyP": "P",
    "Enter": "ENTER",
    "ControlLeft": "CTRL", "ControlRight": "CTRL",
    "KeyA": "A", "KeyS": "S", "KeyD": "D", "KeyF": "F", "KeyG": "G", "KeyH": "H",
    "KeyJ": "J", "KeyK": "K", "KeyL": "L",
    "ShiftLeft": "SHIFT", "ShiftRight": "SHIFT",
    "AltLeft": "ALT", "AltRight": "ALT",
    "KeyZ": "Z", "KeyX": "X", "KeyC": "C", "KeyV": "V", "KeyB": "B", "KeyN": "N",
    "KeyM": "M",
    "CapsLock": "CAPSLOCK",
    "Space": "SPACE",
  };

  const keyElements = {};
  function populateKeyElements() {
    document.querySelectorAll('#mini-kb button').forEach(button => {
      keyElements[button.textContent.toUpperCase()] = button;
    });
  }
  populateKeyElements();

  let isListening = false;
  const toggleListenBtn = document.getElementById('toggle-listen');

  function handleGlobalKeyDown(e) {
    const mappedKey = keyMap[e.code] || e.key.toUpperCase();
    if (mappedKey) {
      sendKey(mappedKey, 'down');
      const btn = keyElements[mappedKey];
      if (btn) {
        btn.classList.add('active'); // Add a class for visual feedback
      }
      e.preventDefault(); // Prevent default browser action for handled keys
    }
  }

  function handleGlobalKeyUp(e) {
    const mappedKey = keyMap[e.code] || e.key.toUpperCase();
    if (mappedKey) {
      sendKey(mappedKey, 'up');
      const btn = keyElements[mappedKey];
      if (btn) {
        btn.classList.remove('active'); // Remove the active class
      }
      e.preventDefault(); // Prevent default browser action for handled keys
    }
  }

  toggleListenBtn.addEventListener('click', () => {
    isListening = !isListening;
    if (isListening) {
      toggleListenBtn.textContent = 'Listening...';
      toggleListenBtn.classList.add('primary');
      window.addEventListener('keydown', handleGlobalKeyDown);
      window.addEventListener('keyup', handleGlobalKeyUp);
    } else {
      toggleListenBtn.textContent = 'Listen to PC Input';
      toggleListenBtn.classList.remove('primary');
      window.removeEventListener('keydown', handleGlobalKeyDown);
      window.removeEventListener('keyup', handleGlobalKeyUp);
    }
  });

  // Add CSS for .active class
  const style = document.createElement('style');
  style.textContent = `
    #mini-kb button.active {
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(108,140,255,.5);
      transform: scale(0.98);
    }
  `;
  document.head.appendChild(style);
  // Wheel buttons: hold to repeat
  let stopUp = null, stopDown = null;
  if (wheelUp){
    wheelUp.onpointerdown = (e)=>{ try{ wheelUp.setPointerCapture(e.pointerId);}catch{}; if (!stopUp) stopUp = startWheelLoop('up'); };
    const end = ()=>{ if (stopUp){ stopUp(); stopUp = null; } };
    wheelUp.onpointerup = end; wheelUp.onpointerleave = end; wheelUp.onpointercancel = end;
  }
  if (wheelDown){
    wheelDown.onpointerdown = (e)=>{ try{ wheelDown.setPointerCapture(e.pointerId);}catch{}; if (!stopDown) stopDown = startWheelLoop('down'); };
    const end = ()=>{ if (stopDown){ stopDown(); stopDown = null; } };
    wheelDown.onpointerup = end; wheelDown.onpointerleave = end; wheelDown.onpointercancel = end;
  }
  </script>
  <div class="panel mt-12">
    <div class="row mb-10">
      <div class="badge">Logs</div>
      <div class="badge muted">Last 500 lines · auto-refresh</div>
      <div class="flex-1"></div>
      <button onclick="openRawLogs()">Open Raw</button>
      <button class="danger" onclick="clearLogs()">Clear</button>
      <button onclick="loadLogs()">Refresh</button>
    </div>
    <div class="terminal small" id="logs"></div>
  </div>

  <div class="footer">
    <div>Built with Flask</div>
    <div class="muted">Be careful: commands run with server permissions.</div>
  </div>
</div>
</body>
</html>
